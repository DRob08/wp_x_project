from django.shortcuts import render
from django.http import HttpResponse
import pandas as pd
from .models import WpPosts
import mysql.connector
from sqlalchemy import create_engine
from aldjemy.core import get_engine
from django.core import serializers
import json
import collections
from django.http import JsonResponse
import pymysql
from django.core import serializers
import decimal, datetime
import smtplib, ssl
from socket import gaierror
from django.core.mail import send_mail
from django.core.mail import EmailMultiAlternatives

from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from sqlalchemy.exc import OperationalError
from sqlalchemy.sql import text
from geotext import GeoText

import urllib.parse

from django.core.mail import EmailMultiAlternatives
from django.http import JsonResponse
from django.template.loader import render_to_string
from sqlalchemy.exc import SQLAlchemyError

import ast
import phpserialize
from io import BytesIO
import re
import datetime

username = 'tomgali1_nomadro'
password = 'Miami@2016'
#host = '35.222.46.172'
host = '35.212.11.153'
database = 'tomgali1_nomadroof'

# URL encode the password
encoded_password = urllib.parse.quote_plus(password)




# Now you can play with your code. Letâ€™s define the SMTP
# server separately here:
port = '2525'
smtp_server = "smtp.mailtrap.io"
login = "6cc65550457616"  # paste your login generated by Mailtrap
password = "6de6c2c3042e53"  # paste your password generated by Mailtrap

EMAIL_HOST = 'smtp.mailtrap.io'
EMAIL_HOST_USER = '6cc65550457616'
EMAIL_HOST_PASSWORD = '6de6c2c3042e53'
EMAIL_PORT = '2525'

# db_connection_str = 'mysql+pymysql://tomgali1_st1:4RgzlqT3xjFC2oap_jkx@35.222.46.172/tomgali1_nomadroof_st1'
#db_connection_str = 'mysql+pymysql://tomgali1_nomadro:Miami@2016@35.222.46.172/tomgali1_nomadroof'
#db_connection_str = 'mysql+pymysql:///tomgali1_nomadro:Miami@2016@35.222.46.172/tomgali1_nomadroof'
#db_connection_str = 'mysql+pymysql://tomgali1_nomadro:Miami@2016@35.222.46.172:3306/tomgali1_nomadroof'

# Create the connection string
db_connection_str = f'mysql+pymysql://{username}:{encoded_password}@{host}/{database}'
#engine = create_engine(db_connection_str, pool_size=90)
engine = create_engine(db_connection_str, pool_size=90, pool_recycle=3600, pool_timeout=30)


# Create your views here.
def home(request):
    try:
        con = engine.connect()

        if con:
            print("Connection successful")

        # sqlqry = (" SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_key, "
        #           "m2.meta_value as check_in, m1.meta_key, "
        #           " m1.meta_value, u1.id, u1.user_login, wp_posts.ID, um.meta_value as first_name, u1.user_email, "
        #           " m3.meta_value, uown.user_email as owner_email, m4.meta_value as check_out, "
        #           "m5.meta_value as prop_id, "
        #           " uown.user_nicename as owneralias, b.post_title as prop_name"
        #           " FROM wp_posts "
        #           " INNER JOIN wp_postmeta m1 "
        #           " ON ( wp_posts.ID = m1.post_id ) "
        #           " INNER JOIN wp_postmeta m2 "
        #           " ON ( wp_posts.ID = m2.post_id ) "
        #           " INNER JOIN wp_postmeta m3 "
        #           " ON ( wp_posts.ID = m3.post_id ) "
        #           " INNER JOIN wp_postmeta m4 "
        #           " ON ( wp_posts.ID = m4.post_id )"
        #           " INNER JOIN wp_users u1 "
        #           " ON(wp_posts.post_author = u1.ID) "
        #           " INNER JOIN wp_usermeta um "
        #           " ON(u1.ID= um.user_id)"
        #           " INNER JOIN wp_users uown "
        #           " ON(m3.meta_value= uown.id) "
        #           " INNER JOIN wp_postmeta m5"
        #           " ON ( wp_posts.ID = m5.post_id ) "
        #           " INNER JOIN wp_posts b "
        #           " ON ( m5.meta_value = b.ID ) "
        #           " WHERE wp_posts.post_type = 'wpestate_booking' "
        #           " AND wp_posts.post_status = 'publish' "
        #           " AND ( m1.meta_key = 'booking_status' AND m1.meta_value = 'confirmed' ) AND "
        #           " ( m2.meta_key = 'booking_from_date' ) and ( m3.meta_key = 'owner_id' "
        #           " AND m3.meta_value <> u1.id ) AND "
        #           " ( m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id ) AND "
        #           " (um.meta_key = 'first_name' and LENGTH(um.meta_value) > 0) "
        #           " AND (m4.meta_key = 'booking_to_date') AND (m5.meta_key = 'booking_id')"
        #           " AND STR_TO_DATE(wp_posts.post_date,'%%Y-%%m-%%d') >= '2019-01-01' "
        #           " ORDER BY wp_posts.post_date DESC ")

        sqlqry = (" SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_key, "
                  "m2.meta_value as check_in, m1.meta_key, "
                  " m1.meta_value, u1.id, u1.user_login, wp_posts.ID, um.meta_value as first_name, u1.user_email, "
                  " m3.meta_value, uown.user_email as owner_email, m4.meta_value as check_out, "
                  "m5.meta_value as prop_id, "
                  " uown.user_nicename as owneralias, b.post_title as prop_name"
                  " FROM wp_posts "
                  " INNER JOIN wp_postmeta m1 "
                  " ON ( wp_posts.ID = m1.post_id ) "
                  " INNER JOIN wp_postmeta m2 "
                  " ON ( wp_posts.ID = m2.post_id ) "
                  " INNER JOIN wp_postmeta m3 "
                  " ON ( wp_posts.ID = m3.post_id ) "
                  " INNER JOIN wp_postmeta m4 "
                  " ON ( wp_posts.ID = m4.post_id )"
                  " INNER JOIN wp_users u1 "
                  " ON(wp_posts.post_author = u1.ID) "
                  " INNER JOIN wp_usermeta um "
                  " ON(u1.ID= um.user_id)"
                  " INNER JOIN wp_users uown "
                  " ON(m3.meta_value= uown.id) "
                  " INNER JOIN wp_postmeta m5"
                  " ON ( wp_posts.ID = m5.post_id ) "
                  " INNER JOIN wp_posts b "
                  " ON ( m5.meta_value = b.ID ) "
                  " WHERE wp_posts.post_type = 'wpestate_booking' "
                  " AND wp_posts.post_status = 'publish' "
                  " AND ( m1.meta_key = 'booking_status' AND m1.meta_value = 'waiting' ) AND "
                  " ( m2.meta_key = 'booking_from_date' ) and ( m3.meta_key = 'owner_id' "
                  " AND m3.meta_value <> u1.id ) AND "
                  " ( m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id ) AND "
                  " (um.meta_key = 'first_name' and LENGTH(um.meta_value) > 0) "
                  " AND (m4.meta_key = 'booking_to_date') AND (m5.meta_key = 'booking_id')"
                  " AND STR_TO_DATE(wp_posts.post_date,'%Y-%m-%d') >= '2022-01-01' "
                  " ORDER BY wp_posts.post_date DESC ")

        rs = con.execute(sqlqry).fetchall()
        #rs = con.execute(text(sqlqry)).fetchall()

        count = len(rs)

        print(count)

        con.close

        bookings_confirmed = rs

        context = {
            'bookings_confirmed': bookings_confirmed

        }

        return render(request, 'wpxapp/home.html', context)

    except Exception as e:
        print(str(e), 'SQL Failed here')
        return render(request, 'wpxapp/home.html')
    

from django.shortcuts import render
from django.db import connection
from sqlalchemy import text

def display_unread_messages(request):
    try:
        con = engine.connect()
        if con:
            print("Connection successful")
        
            sql_query = """
                    SELECT
            DATE_FORMAT(p.post_date, '%m/%d/%Y') AS post_date,
            p.ID,
            p.post_title,
            p.post_content,
            pm.meta_value AS message_from_user,
            m2.meta_value AS message_to_user,
            pm_status.meta_value AS message_status,
            pm_booking.meta_value AS booking_reference_id,
            um_from.meta_value AS from_user_custom_picture,
            um_to.meta_value AS to_user_custom_picture,
            um_from_first_name.meta_value AS from_user_first_name,
            um_to_first_name.meta_value AS to_user_first_name,
            u_from.user_email AS from_user_email,
            u_to.user_email AS to_user_email
        FROM
            wp_posts AS p
            INNER JOIN wp_postmeta AS pm ON p.ID = pm.post_id
            INNER JOIN wp_postmeta AS m2 ON p.ID = m2.post_id
            INNER JOIN wp_postmeta AS pm_status ON p.ID = pm_status.post_id AND pm_status.meta_key = 'message_status' AND pm_status.meta_value = 'unread'
            LEFT JOIN wp_postmeta AS pm_booking ON p.ID = pm_booking.post_id AND pm_booking.meta_key = 'booking_reference_id'
            INNER JOIN wp_usermeta AS um_from ON um_from.user_id = pm.meta_value AND um_from.meta_key = 'custom_picture'
            INNER JOIN wp_usermeta AS um_to ON um_to.user_id = m2.meta_value AND um_to.meta_key = 'custom_picture'
            INNER JOIN wp_usermeta AS um_from_first_name ON um_from_first_name.user_id = pm.meta_value AND um_from_first_name.meta_key = 'first_name'
            INNER JOIN wp_usermeta AS um_to_first_name ON um_to_first_name.user_id = m2.meta_value AND um_to_first_name.meta_key = 'first_name'
            INNER JOIN wp_users AS u_from ON u_from.ID = pm.meta_value
            INNER JOIN wp_users AS u_to ON u_to.ID = m2.meta_value
        WHERE
            p.post_type = 'wpestate_message'
            AND p.post_status = 'publish'
            AND pm.meta_key = 'message_from_user'
            AND m2.meta_key = 'message_to_user'
            AND p.post_date > '2022-01-01'
        ORDER BY p.post_date DESC


            """

            rows = con.execute(text(sql_query)).fetchall()

            con.close()

            # Pass the retrieved records to the template for rendering
            context = {'rows': rows}
            return render(request, 'wpxapp/unread_messages.html', context)
    except SQLAlchemyError as e:
        print(f"Error connecting to the database: {e}")

    return render(request, 'unread_messages.html')


def bad_data(request):
    try:
        con = engine.connect()
        if con:
            print("Connection successful")
        
            sql_query = """
                SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_value as check_in, 
                m1.meta_value as booking_status, u1.id as user_id, u1.user_login, wp_posts.ID, 
                um.meta_value as first_name, u1.user_email, m3.meta_value as owner_email, 
                m4.meta_value as check_out, m5.meta_value as prop_id, m6.meta_value as invoice_no,
                uown.user_nicename as owner_alias, b.post_title as prop_name
                FROM wp_posts
                INNER JOIN wp_postmeta m1 ON wp_posts.ID = m1.post_id
                INNER JOIN wp_postmeta m2 ON wp_posts.ID = m2.post_id
                INNER JOIN wp_postmeta m3 ON wp_posts.ID = m3.post_id
                INNER JOIN wp_postmeta m4 ON wp_posts.ID = m4.post_id
                INNER JOIN wp_users u1 ON wp_posts.post_author = u1.ID
                INNER JOIN wp_usermeta um ON u1.ID = um.user_id
                INNER JOIN wp_users uown ON m3.meta_value = uown.id
                INNER JOIN wp_postmeta m5 ON wp_posts.ID = m5.post_id
                INNER JOIN wp_posts b ON m5.meta_value = b.ID
                INNER JOIN wp_postmeta m6 ON wp_posts.ID = m6.post_id
                WHERE wp_posts.post_type = 'wpestate_booking'
                AND wp_posts.post_status = 'publish'
                AND m1.meta_key = 'booking_status'
                AND m1.meta_value = 'pending'
                AND m2.meta_key = 'booking_from_date'
                AND m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id
                AND (um.meta_key = 'first_name' AND LENGTH(um.meta_value) > 0)
                AND m4.meta_key = 'booking_to_date'
                AND m5.meta_key = 'booking_id'
                AND m6.meta_key = 'booking_invoice_no'
                AND (
                    SUBSTRING_INDEX(m4.meta_value, ' ', 1) IN ('Ene', 'Abr', 'Ago', 'Dic')
                    OR
                    SUBSTRING_INDEX(m2.meta_value, ' ', 1) IN ('Ene', 'Abr', 'Ago', 'Dic')
                )
                AND STR_TO_DATE(wp_posts.post_date, '%Y-%m-%d') >= '2019-01-01'
                ORDER BY wp_posts.post_date DESC
            """

            sql_query = """
            SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_value as check_in, 
            m1.meta_value as booking_status, u1.id as user_id, u1.user_login, wp_posts.ID, 
            um.meta_value as first_name, u1.user_email, m3.meta_value as owner_email, 
            m4.meta_value as check_out, m5.meta_value as prop_id, m6.meta_value as invoice_no,
            uown.user_nicename as owner_alias, b.post_title as prop_name
            FROM wp_posts
            INNER JOIN wp_postmeta m1 ON wp_posts.ID = m1.post_id
            INNER JOIN wp_postmeta m2 ON wp_posts.ID = m2.post_id
            INNER JOIN wp_postmeta m3 ON wp_posts.ID = m3.post_id
            INNER JOIN wp_postmeta m4 ON wp_posts.ID = m4.post_id
            INNER JOIN wp_users u1 ON wp_posts.post_author = u1.ID
            INNER JOIN wp_usermeta um ON u1.ID = um.user_id
            INNER JOIN wp_users uown ON m3.meta_value = uown.id
            INNER JOIN wp_postmeta m5 ON wp_posts.ID = m5.post_id
            INNER JOIN wp_posts b ON m5.meta_value = b.ID
            INNER JOIN wp_postmeta m6 ON wp_posts.ID = m6.post_id
            WHERE wp_posts.post_type = 'wpestate_booking'
            AND wp_posts.post_status = 'publish'
            AND m1.meta_key = 'booking_status'
            AND (m1.meta_value = 'pending' OR m1.meta_value = 'canceled')
            AND m2.meta_key = 'booking_from_date'
            AND m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id
            AND (um.meta_key = 'first_name' AND LENGTH(um.meta_value) > 0)
            AND m4.meta_key = 'booking_to_date'
            AND m5.meta_key = 'booking_id'
            AND m6.meta_key = 'booking_invoice_no'
            AND (
                SUBSTRING_INDEX(m4.meta_value, ' ', 1) IN ('Ene', 'Abr', 'Ago', 'Dic')
                OR
                SUBSTRING_INDEX(m2.meta_value, ' ', 1) IN ('Ene', 'Abr', 'Ago', 'Dic')
            )
            AND STR_TO_DATE(wp_posts.post_date, '%Y-%m-%d') >= '2019-01-01'
            ORDER BY wp_posts.post_date DESC
        """

            rows = con.execute(text(sql_query)).fetchall()

            con.close()

            # Pass the retrieved records to the template for rendering
            context = {'rows': rows}
            return render(request, 'wpxapp/bad_data.html', context)
    except SQLAlchemyError as e:
        print(f"Error connecting to the database: {e}")

    return render(request, 'wpxapp/bad_data.html') 



def fix_data(request):
    if request.method == 'POST' and request.is_ajax():
        data = json.loads(request.body)  # Assuming the data is sent as JSON
        
        # Perform the necessary modifications on the data
        con = engine.connect()
        
        # Helper function to convert Spanish month to English
        def convert_month_to_english(date_str):
            spanish_months = {
                'Ene': 'Jan',
            
                'Abr': 'Apr',
             
                'Ago': 'Aug',
         
                'Dic': 'Dec',
            }
            for month in spanish_months:
                if month in date_str:
                    date_str = date_str.replace(month, spanish_months[month])
            return date_str
        
        # Update values in the wp_postmeta table based on post_id
        for item in data:
            post_id = item['postId']
            check_in = item['checkIn']
            check_out = item['checkOut']
            
            # Convert check_in and check_out to English month if they are in Spanish
            check_in = convert_month_to_english(check_in)
            check_out = convert_month_to_english(check_out)
            
            print(post_id)
            print(check_in)
            print(check_out)
            
            # Perform the modifications on check_in and check_out values, e.g., converting to English month
            
            # Example SQL query to update the values in the wp_postmeta table
            sql_query = """
                UPDATE wp_postmeta
                SET meta_value = :check_in
                WHERE post_id = :post_id AND meta_key = 'booking_from_date'
            """
            con.execute(text(sql_query), {'check_in': check_in, 'post_id': post_id})
            
            sql_query = """
                UPDATE wp_postmeta
                SET meta_value = :check_out
                WHERE post_id = :post_id AND meta_key = 'booking_to_date'
            """
            con.execute(text(sql_query), {'check_out': check_out, 'post_id': post_id})
        
        # Return a JSON response indicating success
        response = {'message': 'Data fixed successfully'}
        return JsonResponse(response, status=200)
    
    # Return a JSON response indicating error
    response = {'message': 'Invalid request'}
    return JsonResponse(response, status=400)



def about(request):
    return HttpResponse('<h1> ABOUT APP </h1>')

def registered_users(request):
    con = engine.connect()
    sqlqry = """
        SELECT 
            wp_users.user_email,
            wp_users.display_name,
            m1.meta_value AS first_name,
            m2.meta_value AS last_name,
            m3.meta_value AS country,
            m4.meta_value AS phone,
            YEAR(wp_users.user_registered) AS registration_year
        FROM wp_users
        INNER JOIN wp_usermeta ON wp_users.ID = wp_usermeta.user_id
        INNER JOIN wp_usermeta m1 ON wp_users.ID = m1.user_id
        INNER JOIN wp_usermeta m2 ON wp_users.ID = m2.user_id
         INNER JOIN wp_usermeta m3 ON wp_users.ID = m3.user_id
         INNER JOIN wp_usermeta m4 ON wp_users.ID = m4.user_id
        WHERE wp_usermeta.meta_key = 'wp_capabilities'
            AND wp_usermeta.meta_value LIKE '%subscriber%'
            AND (m1.meta_key = 'first_name')
            AND (m2.meta_key = 'last_name')
            AND wp_users.user_email IS NOT NULL
            AND LENGTH(wp_users.user_email) <> 0
            AND (m3.meta_key = 'live_in')
            AND (m4.meta_key = 'mobile')
         ORDER BY YEAR(wp_users.user_registered) DESC, wp_users.user_registered DESC
      
    """

    result = con.execute(text(sqlqry)).fetchall()

    con.close

    users = {}
    for row in result:
        email, display_name, first_name, last_name,country, phone, registration_year = row
        places = GeoText(country)
        found_countries = places.countries
        #country = places.countries

       #print(found_countries)
        user_data = {
            'email': email,
            'first_name': first_name,
            'last_name': last_name,
            'country': country,
            'phone': phone,
        }
        if registration_year not in users:
            users[registration_year] = []
        users[registration_year].append(user_data)

    context = {
        'users': users,
    }

    return render(request, 'wpxapp/registered_users.html', context)



def bookings_status(request):
    try:
        con = engine.connect()
        booking_status = request.GET['bookingstype']
        
        status_mapping = {
            'Pending': 'pending',
            'Confirmed': 'confirmed',
            'Waiting': 'waiting',
            'Cancel': 'canceled'
        }
        
        status_value = status_mapping.get(booking_status, None)
        
        if status_value is None:
            raise ValueError(f"Invalid booking status: {booking_status}")
        
        sqlqry = f"""
        SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_value as check_in, 
        m1.meta_value as booking_status, u1.id as user_id, u1.user_login, wp_posts.ID, 
        um.meta_value as first_name, u1.user_email, m3.meta_value as owner_email, 
        m4.meta_value as check_out, m5.meta_value as prop_id, m6.meta_value as invoice_no,
        uown.user_nicename as owner_alias, b.post_title as prop_name
        FROM wp_posts
        INNER JOIN wp_postmeta m1 ON wp_posts.ID = m1.post_id
        INNER JOIN wp_postmeta m2 ON wp_posts.ID = m2.post_id
        INNER JOIN wp_postmeta m3 ON wp_posts.ID = m3.post_id
        INNER JOIN wp_postmeta m4 ON wp_posts.ID = m4.post_id
        INNER JOIN wp_users u1 ON wp_posts.post_author = u1.ID
        INNER JOIN wp_usermeta um ON u1.ID = um.user_id
        INNER JOIN wp_users uown ON m3.meta_value = uown.id
        INNER JOIN wp_postmeta m5 ON wp_posts.ID = m5.post_id
        INNER JOIN wp_posts b ON m5.meta_value = b.ID
        INNER JOIN wp_postmeta m6 ON wp_posts.ID = m6.post_id
        WHERE wp_posts.post_type = 'wpestate_booking'
        AND wp_posts.post_status = 'publish'
        AND m1.meta_key = 'booking_status'
        AND m1.meta_value = '{status_value}'
        AND m2.meta_key = 'booking_from_date'
        AND m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id
        AND (um.meta_key = 'first_name' AND LENGTH(um.meta_value) > 0)
        AND m4.meta_key = 'booking_to_date'
        AND m5.meta_key = 'booking_id'
        AND m6.meta_key = 'booking_invoice_no'
        AND STR_TO_DATE(wp_posts.post_date, '%Y-%m-%d') >= '2022-01-01'
        ORDER BY wp_posts.post_date DESC
        """
        #print(sqlqry)
        result = con.execute(text(sqlqry)).fetchall()
        count = len(result)

        data = []
        for row in result:
            item = {
                'post_date': row[0].strftime('%Y-%m-%d %H:%M:%S'),
                'post_title': row[1],
                'booking_from_date': row[2],
                'booking_status': row[3],
                'user_id': row[4],
                'user_login': row[5],
                'ID': row[6],
                'first_name': row[7],
                'user_email': row[8],
                'owner_email': row[9],
                'booking_to_date': row[10],
                'prop_id': row[11],
                'invoice_no': row[12],
                'owneralias': row[13],
                'prop_name': row[14]
            }
            data.append(item)
           

        json_data = json.dumps(data)
        #print(json_data)
        con.close
       
        #json_data = json.dumps([dict(r) for r in result], default=alchemyencoder)

        return HttpResponse(json_data, content_type='application/json')

    except Exception as e:
        response = {
            'status': 'error',
            'message': str(e)
        }
        return JsonResponse(response)



def bookings_status2(request):
    try:
        con = engine.connect()

        booking_status = request.GET['bookingstype']

        sqlqry = ""

        if booking_status == "Pending":

            sqlqry = (" SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_key, "
                      "m2.meta_value as check_in, m1.meta_key, "
                      " m1.meta_value as status, u1.id, u1.user_login, wp_posts.ID, "
                      "um.meta_value as first_name, u1.user_email, "
                      " m3.meta_value, uown.user_email as owner_email, m4.meta_value as check_out, "
                      "m5.meta_value as prop_id, "
                      " uown.user_nicename as owneralias, b.post_title as prop_name"
                      " FROM wp_posts "
                      " INNER JOIN wp_postmeta m1 "
                      " ON ( wp_posts.ID = m1.post_id ) "
                      " INNER JOIN wp_postmeta m2 "
                      " ON ( wp_posts.ID = m2.post_id ) "
                      " INNER JOIN wp_postmeta m3 "
                      " ON ( wp_posts.ID = m3.post_id ) "
                      " INNER JOIN wp_postmeta m4 "
                      " ON ( wp_posts.ID = m4.post_id )"
                      " INNER JOIN wp_users u1 "
                      " ON(wp_posts.post_author = u1.ID) "
                      " INNER JOIN wp_usermeta um "
                      " ON(u1.ID= um.user_id)"
                      " INNER JOIN wp_users uown "
                      " ON(m3.meta_value= uown.id) "
                      " INNER JOIN wp_postmeta m5"
                      " ON ( wp_posts.ID = m5.post_id ) "
                      " INNER JOIN wp_posts b "
                      " ON ( m5.meta_value = b.ID ) "
                      " WHERE wp_posts.post_type = 'wpestate_booking' "
                      " AND wp_posts.post_status = 'publish' "
                      " AND ( m1.meta_key = 'booking_status' AND m1.meta_value = 'pending' ) AND "
                      " ( m2.meta_key = 'booking_from_date' ) and ( m3.meta_key = 'owner_id' "
                      " AND m3.meta_value <> u1.id ) AND "
                      " ( m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id ) AND "
                      " (um.meta_key = 'first_name' and LENGTH(um.meta_value) > 0) "
                      " AND (m4.meta_key = 'booking_to_date') AND (m5.meta_key = 'booking_id')"
                      " AND STR_TO_DATE(wp_posts.post_date,'%Y-%m-%d') >= '2022-01-01' "
                      " ORDER BY wp_posts.post_date DESC ")
            

          

        elif booking_status == "Confirmed":

            sqlqry = (" SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_key, "
                      "m2.meta_value as check_in, m1.meta_key, "
                      " m1.meta_value as status, u1.id, u1.user_login, wp_posts.ID, "
                      "um.meta_value as first_name, u1.user_email, "
                      " m3.meta_value, uown.user_email as owner_email, m4.meta_value as check_out, "
                      "m5.meta_value as prop_id, m6.meta_value as invoice_no,"
                      " uown.user_nicename as owneralias, b.post_title as prop_name"
                      " FROM wp_posts "
                      " INNER JOIN wp_postmeta m1 "
                      " ON ( wp_posts.ID = m1.post_id ) "
                      " INNER JOIN wp_postmeta m2 "
                      " ON ( wp_posts.ID = m2.post_id ) "
                      " INNER JOIN wp_postmeta m3 "
                      " ON ( wp_posts.ID = m3.post_id ) "
                      " INNER JOIN wp_postmeta m4 "
                      " ON ( wp_posts.ID = m4.post_id )"
                      " INNER JOIN wp_users u1 "
                      " ON(wp_posts.post_author = u1.ID) "
                      " INNER JOIN wp_usermeta um "
                      " ON(u1.ID= um.user_id)"
                      " INNER JOIN wp_users uown "
                      " ON(m3.meta_value= uown.id) "
                      " INNER JOIN wp_postmeta m5"
                      " ON ( wp_posts.ID = m5.post_id ) "
                      " INNER JOIN wp_posts b "
                      " ON ( m5.meta_value = b.ID ) "
                      " INNER JOIN wp_postmeta m6"
                      " ON ( wp_posts.ID = m6.post_id ) "
                      " WHERE wp_posts.post_type = 'wpestate_booking' "
                      " AND wp_posts.post_status = 'publish' "
                      " AND ( m1.meta_key = 'booking_status' AND m1.meta_value = 'confirmed' ) AND "
                      " ( m2.meta_key = 'booking_from_date' ) and ( m3.meta_key = 'owner_id' "
                      " AND m3.meta_value <> u1.id ) AND "
                      " ( m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id ) AND "
                      " (um.meta_key = 'first_name' and LENGTH(um.meta_value) > 0) "
                      " AND (m4.meta_key = 'booking_to_date') AND (m5.meta_key = 'booking_id') "
                      "AND (m6.meta_key = 'booking_invoice_no')"
                      " AND STR_TO_DATE(wp_posts.post_date,'%Y-%m-%d') >= '2022-01-01' "
                      " ORDER BY wp_posts.post_date DESC ")
            
      
            
            

        elif booking_status == "Waiting":

            sqlqry = (" SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_key, "
                      "m2.meta_value as check_in, m1.meta_key, "
                      " m1.meta_value as status, u1.id, u1.user_login, wp_posts.ID, "
                      "um.meta_value as first_name, u1.user_email, "
                      " m3.meta_value, uown.user_email as owner_email, m4.meta_value as check_out, "
                      "m5.meta_value as prop_id, "
                      " uown.user_nicename as owneralias, b.post_title as prop_name"
                      " FROM wp_posts "
                      " INNER JOIN wp_postmeta m1 "
                      " ON ( wp_posts.ID = m1.post_id ) "
                      " INNER JOIN wp_postmeta m2 "
                      " ON ( wp_posts.ID = m2.post_id ) "
                      " INNER JOIN wp_postmeta m3 "
                      " ON ( wp_posts.ID = m3.post_id ) "
                      " INNER JOIN wp_postmeta m4 "
                      " ON ( wp_posts.ID = m4.post_id )"
                      " INNER JOIN wp_users u1 "
                      " ON(wp_posts.post_author = u1.ID) "
                      " INNER JOIN wp_usermeta um "
                      " ON(u1.ID= um.user_id)"
                      " INNER JOIN wp_users uown "
                      " ON(m3.meta_value= uown.id) "
                      " INNER JOIN wp_postmeta m5"
                      " ON ( wp_posts.ID = m5.post_id ) "
                      " INNER JOIN wp_posts b "
                      " ON ( m5.meta_value = b.ID ) "
                      " WHERE wp_posts.post_type = 'wpestate_booking' "
                      " AND wp_posts.post_status = 'publish' "
                      " AND ( m1.meta_key = 'booking_status' AND m1.meta_value = 'waiting' ) AND "
                      " ( m2.meta_key = 'booking_from_date' ) and ( m3.meta_key = 'owner_id' "
                      " AND m3.meta_value <> u1.id ) AND "
                      " ( m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id ) AND "
                      " (um.meta_key = 'first_name' and LENGTH(um.meta_value) > 0) "
                      " AND (m4.meta_key = 'booking_to_date') AND (m5.meta_key = 'booking_id')"
                      " AND STR_TO_DATE(wp_posts.post_date,'%Y-%m-%d') >= '2022-01-01' "
                      " ORDER BY wp_posts.post_date DESC ")
            
            


        elif booking_status == "Cancel":

            sqlqry = (" SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_key, "
                      "m2.meta_value as check_in, m1.meta_key, "
                      " m1.meta_value as status, u1.id, u1.user_login, wp_posts.ID, "
                      "um.meta_value as first_name, u1.user_email, "
                      " m3.meta_value, uown.user_email as owner_email, m4.meta_value as check_out, "
                      "m5.meta_value as prop_id, "
                      " uown.user_nicename as owneralias, b.post_title as prop_name"
                      " FROM wp_posts "
                      " INNER JOIN wp_postmeta m1 "
                      " ON ( wp_posts.ID = m1.post_id ) "
                      " INNER JOIN wp_postmeta m2 "
                      " ON ( wp_posts.ID = m2.post_id ) "
                      " INNER JOIN wp_postmeta m3 "
                      " ON ( wp_posts.ID = m3.post_id ) "
                      " INNER JOIN wp_postmeta m4 "
                      " ON ( wp_posts.ID = m4.post_id )"
                      " INNER JOIN wp_users u1 "
                      " ON(wp_posts.post_author = u1.ID) "
                      " INNER JOIN wp_usermeta um "
                      " ON(u1.ID= um.user_id)"
                      " INNER JOIN wp_users uown "
                      " ON(m3.meta_value= uown.id) "
                      " INNER JOIN wp_postmeta m5"
                      " ON ( wp_posts.ID = m5.post_id ) "
                      " INNER JOIN wp_posts b "
                      " ON ( m5.meta_value = b.ID ) "
                      " WHERE wp_posts.post_type = 'wpestate_booking' "
                      " AND wp_posts.post_status = 'publish' "
                      " AND ( m1.meta_key = 'booking_status' AND m1.meta_value = 'canceled' ) AND "
                      " ( m2.meta_key = 'booking_from_date' ) and ( m3.meta_key = 'owner_id' "
                      " AND m3.meta_value <> u1.id ) AND "
                      " ( m3.meta_key = 'owner_id' AND m3.meta_value <> u1.id ) AND "
                      " (um.meta_key = 'first_name' and LENGTH(um.meta_value) > 0) "
                      " AND (m4.meta_key = 'booking_to_date') AND (m5.meta_key = 'booking_id')"
                      " AND STR_TO_DATE(wp_posts.post_date,'%Y-%m-%d') >= '2022-01-01' "
                      " ORDER BY wp_posts.post_date DESC ")
            
          

        #result = con.execute(sqlqry).fetchall()
        result = con.execute(text(sqlqry)).fetchall()
        count = len(result)
       # print(result)

        data = []
        for row in result:
            item = {
                'post_date': row[0].strftime('%Y-%m-%d %H:%M:%S'),
                'post_title': row[1],
                'booking_from_date': row[3],
                'booking_status': row[5],
                'user_id': row[6],
                'user_login': row[7],
                'ID': row[8],
                'first_name': row[9],
                'user_email': row[10],
                'owner_email': row[12],
                'booking_to_date': row[13],
                'prop_id': row[14],
                'invoice_no': row[15],
                'owneralias': row[16],
                'prop_name': row[17]
            }
            data.append(item)
        print(data)

        # Convert data to JSON
        json_data = json.dumps(data)
        
        con.close
       
        #json_data = json.dumps([dict(r) for r in result], default=alchemyencoder)

        return HttpResponse(json_data, content_type='application/json')

    except Exception as e:

        print(str(e), 'Querying Booking Status Failed - SQL')
        dictlogs = {}
        return HttpResponse(dictlogs, content_type='application/json')


def alchemyencoder(obj):
    """JSON encoder function for SQLAlchemy special classes."""
    if isinstance(obj, datetime.date):
        return obj.isoformat()
    elif isinstance(obj, datetime.datetime):
        return obj.strftime('%Y-%m-%d %H:%M:%S')
    elif isinstance(obj, decimal.Decimal):
        return float(obj)



def sendemail(request):
    # Specify the senderâ€™s and receiverâ€™s email addresses:
    sender = "from@example.com"
    receiver = "mailtrap@example.com"

    email = request.GET['email']
    tenant = request.GET['tenant']
    checkin = request.GET['checkin']
    checkout = request.GET['checkout']
    period = request.GET['period']
    host = request.GET['host']
    property = request.GET['property']

    # Type your message: use two newlines (\n) to separate the subject from the message body, and use 'f' to
    # automatically insert variables in the text

    message = f"""\
    Subject: Hi Mailtrap
    To: {receiver}
    From: {sender}
    This is my first message with Python."""

    try:
        # Send your message with credentials specified above
        # with smtplib.SMTP(smtp_server, 2525) as server:
        #     server.login(login, password)
        #     server.sendmail(sender, receiver, message)

        # send_mail(
        #     subject='Thatâ€™s your subject',
        #     message = 'Thatâ€™s your message body',
        #     from_email = "customerservice@nomadroof.com",
        #     recipient_list = ['abc0ebfdde-1c7aba@inbox.mailtrap.io','customersupport@nomadroof.com'],
        #     fail_silently = False,
        # )

        subject, from_email, to = 'hello', 'customerservice@nomadroof.com', 'customersupport@nomadroof.com'
        text_content = 'This is an important message.'
        # html_content = '<h1>This is an <strong>important</strong> message.</h1>'
        html_content = ('<html> < table style = "width:100%" >' 
                        '< tr >' 
                        '   < th > Firstname < / th >'
                        '   < th > Lastname < / th >'
                        '   < th > Age < / th >'
                        '< / tr >'
                        '< tr >'
                        '   < td > Jill < / td >'
                        '   < td > Smith < / td >'
                        '   < td > 50 < / td >'
                        '< / tr >'
                        '< tr >'
                        '   < td > Eve < / td >'
                        '   < td > Jackson < / td >'
                        '   < td > 94 < / td >'
                        '< / tr >'
                        '< / table > </html>')

        msg = EmailMultiAlternatives(subject, text_content, from_email, [to])
        msg.attach_alternative(html_content, "text/html")
        msg.content_subtype = "html"
        msg.send()

        data = {
            'name': 'Vitor',
            'location': 'Finland',
            'is_active': True,
            'count': 28
        }

        return JsonResponse(data)

    except (gaierror, ConnectionRefusedError):
        # tell the script to report if your message was sent or which errors need to be fixed
        print('Failed to connect to the server. Bad connection settings?')
    except smtplib.SMTPServerDisconnected:
        print('Failed to connect to the server. Wrong user/password?')
    except smtplib.SMTPException as e:
        print('SMTP error occurred: ' + str(e))
    else:
        print('Sent')


def sendemail_other(request):

    email = request.GET['email']
    tenant = request.GET['tenant']
    checkin = request.GET['checkin']
    checkout = request.GET['checkout']
    period = request.GET['period']
    host = request.GET['host']
    property = request.GET['property']
    rows = json.loads(request.GET['rows'])

    tblrows = ""

    for bookings in rows:
        tenant = bookings["tenant"]

        tblrows = tblrows + """\
                <tr>
                    <td>""" + bookings["tenant"] + """</td>
                    <td>""" + bookings["email"] + """</td>
                    <td>""" + bookings["checkin"] + """</td>
                    <td>""" + bookings["checkout"] + """</td>
                    <td>""" + bookings["period"] + """</td>
                    <td>""" + bookings["property"] + """</td>
                    <td>""" + bookings["host"]  + """</td>
                 </tr>
              """

    for tenants in rows:
        for k, v in tenants.items():
            print('{}: {}'.format(k, v))

    # Type your message: use two newlines (\n) to separate the subject from the message body, and use 'f' to
    # automatically insert variables in the text
    try:
        sender_email = "customerservice@nomadroof.com"
        # receiver_email = "customersupport@nomadroof.com"
        # receiver_email = "tomg_g@hotmail.com"
        receiver_email = "darwin.robinson8@gmail.com; customersupport@nomadroof.com"
        password = 'Mi@mi2020'

        message = MIMEMultipart("alternative")
        message["Subject"] = "Nomadroof Booking/Tenant"
        message["From"] = sender_email
        message["To"] = receiver_email

        # Create the plain-text and HTML version of your message
        text = """\
        Hi,
        How are you?
        Real Python has many great tutorials:
        www.realpython.com"""

        html = """\
        <html>
          <body>
            <table>
              <tr>
                <th>Tenant</th>
                <th>Email</th>
                <th>Check-In</th>
                <th>Check-Out</th>
                <th>Period</th>
                <th>Property</th>
                <th>Host</th>
              </tr>
              <tr>
                <td>""" + tenant + """</td>
                <td>""" + email + """</td>
                <td>""" + checkin + """</td>
                <td>""" + checkout + """</td>
                <td>""" + period + """</td>
                <td>""" + property + """</td>
                <td>""" + host + """</td>
              </tr>
            </table> 
          </body>
        </html>
        """

        myhtml = """\
               <html>
                 <body>
                   <table>
                     <tr>
                       <th>Tenant</th>
                       <th>Email</th>
                       <th>Check-In</th>
                       <th>Check-Out</th>
                       <th>Period</th>
                       <th>Property</th>
                       <th>Host</th>
                     </tr>
                     """ + tblrows + """
                   </table> 
                 </body>
               </html>
               """

        # Turn these into plain/html MIMEText objects
        part1 = MIMEText(text, "plain")
        part2 = MIMEText(myhtml, "html")

        # Add HTML/plain-text parts to MIMEMultipart message
        # The email client will try to render the last part first
        message.attach(part1)
        message.attach(part2)

        # Create secure connection with server and send email
        context = ssl._create_unverified_context(cert_reqs=ssl.CERT_NONE)

        with smtplib.SMTP_SSL("mail.nomadroof.com", 465) as server:
            server.login(sender_email, password)
            server.sendmail(
                sender_email, receiver_email, message.as_string()
            )
        data = {
            'name': 'Vitor',
            'location': 'Finland',
            'is_active': True,
            'count': 28
        }

        return JsonResponse(data)

    except (gaierror, ConnectionRefusedError):
        # tell the script to report if your message was sent or which errors need to be fixed
        print('Failed to connect to the server. Bad connection settings?')
    except smtplib.SMTPServerDisconnected:
        print('Failed to connect to the server. Wrong user/password?')
    except smtplib.SMTPException as e:
        print('SMTP error occurred: ' + str(e))
    else:
        print('Sent')



def get_image_urls(data):
    parsed_data = ast.literal_eval(data)
    file_urls = []

    # Add the main file URL
    file_urls.append(parsed_data['file'])

    # Iterate over the 'sizes' dictionary and extract the file URLs
    for size, details in parsed_data['sizes'].items():
        file_urls.append(details['file'])

    return file_urls

def send_received_message_email(request):
    #rows = json.loads(request.GET.get('rows'))
    #rows = json.loads(request.body)['rows']

    #rows = json.loads(request.GET.get('rows'))

    #rows = json.loads(request.POST.get('rows', '[]'))

    rows = json.loads(request.GET.get('rows'))
  

    print("Send email TESTING")

    for message in rows:
        profile_picture_url = message.get('profile_picture_url') 
        sender_first_name = message.get('from_name')
        receiver_name = message.get('receiver_name')
        receiver_email = message.get('receiver_email')

        print("Looping")
        print(profile_picture_url)
        print(sender_first_name)
        print(receiver_name)
        print(receiver_email)

        # Load the email template and populate it with data
        html_content = render_to_string('wpxapp/received_message_email_template.html', {
            'profilePictureUrl': profile_picture_url,
            'senderFirstName': sender_first_name,
            'receiverFirstName': receiver_name,
            'receiverEmail': receiver_email,
        })

        # Create the email message
        subject = 'New Message Notification'
        from_email = 'Nomadroof <no-reply@nomadroof.com>'
        to_email = [receiver_email] 

        bcc_email = ['darwin.robinson8@gmail.com']  # Your email address
        message = EmailMultiAlternatives(subject, '', from_email, to_email, bcc_email)
        #message = EmailMultiAlternatives(subject, '', from_email, to_email)
        message.attach_alternative(html_content, "text/html")

        try:
            # Send the email
            message.send()
            print("I am sending email")
        except Exception as e:
            # Return a JSON response with an error message
            data = {
                'error': f'Failed to send email to {receiver_email}: {str(e)}'
            }
            return JsonResponse(data, status=500)

    # Return a JSON response indicating success
    data = {
        'message': 'Emails sent successfully.'
    }
    return JsonResponse(data)

def sendegeneralemail(request):
 
    #rows = json.loads(request.GET.get('rows'))
    
    #selected_emails = request.GET.getlist('selected_emails')

    

    rows = json.loads(request.GET.get('rows'))

    print(" I am here")
    print(rows)

    for user in rows:

       

        email = user["email"]
        print(email)

         # Load the email template and populate it with data
        html_content = render_to_string('wpxapp/showcase_email_template.html', {
        })

        # Create the email message
        subject = 'Did you see our latest student properties in Lima?'
        from_email = 'Nomadroof <no-reply@nomadroof.com>'
        to_email = [email]  # Use the recipient's email address
       
        bcc_email = ['darwin.robinson8@gmail.com']  # Your email address
        message = EmailMultiAlternatives(subject, '', from_email, to_email, bcc_email)
        #message = EmailMultiAlternatives(subject, '', from_email, to_email)
        message.attach_alternative(html_content, "text/html")

        try:
            # Send the email
            message.send()

            print('I am sending email.......')
        except Exception as e:
            # Return a JSON response with an error message
            data = {
                'error': f'Failed to send email to {email}: {str(e)}'
            }
            return JsonResponse(data, status=500)

    # Return a JSON response indicating success
    data = {
        'message': 'Emails sent successfully.'
    }
    return JsonResponse(data)


def sendemailpending(request):
    con = engine.connect()

    rows = json.loads(request.GET.get('rows'))

    for booking in rows:
        tenant = booking["tenant"]
        email = booking["email"]
        checkin = booking["checkin"]
        checkout = booking["checkout"]
        period = booking["period"]
        host = booking["host"]
        property_name = booking["property"]
        bookid = booking["bookid"]
        invno = booking["invno"]

        split_data = property_name.split('--')

        # Extract the number and text after the dashes
        property_id = split_data[0].strip()
        property_name = split_data[1].strip()

        print("Property ID:", property_id)
        print("Name:", property_name)
         
        
        print("Inv #:", invno)

        sqlqry = f"""
        SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_value as property_address, 
        m1.meta_value as about_neighborhood, m3.meta_value images_id, m4.meta_value as image_path, m5.meta_value as images_data
        FROM wp_posts
        INNER JOIN wp_postmeta m1 ON wp_posts.ID = m1.post_id
        INNER JOIN wp_postmeta m2 ON wp_posts.ID = m2.post_id
        INNER JOIN wp_postmeta m3 ON wp_posts.ID = m3.post_id
        INNER JOIN wp_postmeta m4 ON m3.meta_value = m4.post_id
        INNER JOIN wp_postmeta m5 ON m3.meta_value = m5.post_id
        WHERE wp_posts.post_type = 'estate_property'
        AND wp_posts.post_status = 'publish'
        AND wp_posts.ID = '{property_id}'
        AND m1.meta_key = 'about_neighborhood'
        AND m2.meta_key = 'property_address'
        AND m3.meta_key = '_thumbnail_id'
        AND m4.meta_key = '_wp_attached_file'
        AND m5.meta_key = '_wp_attachment_metadata'
      
        """

        print(sqlqry)
        result = con.execute(text(sqlqry)).fetchall()
        count = len(result)

        row = result[0]  # Get the first (and only) row

        # Access values using indexing
        post_date = row[0]
        post_title = row[1]
        property_address = row[2]
        about_neighborhood = row[3]

        # Or access values using attribute-based access
        post_date = row.post_date
        post_title = row.post_title
        property_address = row.property_address
        about_neighborhood = row.about_neighborhood
        images_id = row.images_id
        image_path = row.image_path
        images_data = row.images_data

        # Print the values
        print("Post Date:", post_date)
        print("Post Title:", post_title)
        print("Property Address:", property_address)
        print("About Neighborhood:", about_neighborhood)
        print("Images ID:", images_id)
        print("Images path:", image_path)

        # Extract strings with ".jpg"
        jpg_strings = re.findall(r'"([^"]*\.jpg)"', images_data)

        # Extract half paths
        half_paths = [string.split(':')[-1] for string in jpg_strings]

        print(half_paths)

        if 'SPANISH' in about_neighborhood:
            # Remove text after "SPANISH" and including "SPANISH"
            about_neighborhood = about_neighborhood[:about_neighborhood.index('SPANISH')]
            print("About Neighborhood:", about_neighborhood)
        

        # Remove dashes at the beginning of sentences
        about_neighborhood = re.sub(r'^-\s*', '', about_neighborhood, flags=re.MULTILINE)

        # Build the complete image path
       # Construct the complete image URL
        complete_image_path = 'https://www.nomadroof.com/wp-content/uploads/' + image_path

        print("FULL path:", complete_image_path)

        # Load the email template and populate it with data
        html_content = render_to_string('wpxapp/pending_email_template.html', {
            'tenant': tenant,
            'checkin': checkin,
            'checkout': checkout,
            'period': period,
            'host': host,
            'property_name': property_name,
            'booking_number': bookid,
            'invoice_number': invno,
            'about_neighborhood': about_neighborhood,
            'image_path': complete_image_path,
            
        })

        # Create the email message
        subject = 'Reservation Confirmation Reminder'
        from_email = 'Nomadroof <no-reply@nomadroof.com>'
        to_email = [email]  # Use the recipient's email address
        #to_email = ['darwin.robinson8@gmail.com']  # Use the recipient's email address
        bcc_email = ['darwin.robinson8@gmail.com']  # Your email address
        message = EmailMultiAlternatives(subject, '', from_email, to_email, bcc_email)
        #message = EmailMultiAlternatives(subject, '', from_email, to_email)
        message.attach_alternative(html_content, "text/html")

        try:
            # Send the email
            message.send()
        except Exception as e:
            # Return a JSON response with an error message
            data = {
                'error': f'Failed to send email to {email}: {str(e)}'
            }
            return JsonResponse(data, status=500)

    # Return a JSON response indicating success
    data = {
        'message': 'Emails sent successfully.'
    }
    return JsonResponse(data)


def sendemailreceipt(request):
    con = engine.connect()

    rows = json.loads(request.GET.get('rows'))

    for booking in rows:
        tenant = booking["tenant"]
        email = booking["email"]
        checkin = booking["checkin"]
        checkout = booking["checkout"]
        period = booking["period"]
        host = booking["host"]
        property_name = booking["property"]
        bookid = booking["bookid"]
        invno = booking["invno"]
      


        # Split the string at the dash and take the first part
        bookid = bookid.split("-")[0]

        # Remove any leading or trailing whitespace
        bookid = bookid.strip()

        print(bookid)

        receipt_number = bookid + invno

        split_data = property_name.split('--')

        # Extract the number and text after the dashes
        property_id = split_data[0].strip()
        property_name = split_data[1].strip()

        print("Property ID:", property_id)
        print("Name:", property_name)
         
        
        print("Inv #:", invno)

        sqlqry = f"""
        SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_value as property_address, 
        m1.meta_value as about_neighborhood, m3.meta_value images_id, m4.meta_value as image_path,
        m5.meta_value as images_data, m6.meta_value as monthly_fee, m7.meta_value as total_paid, um.meta_value as first_name, 
        um2.meta_value as last_name, m8.meta_value, wp_posts.post_author, m9.meta_value as inv_date, mt.meta_value as item_price_total
        FROM wp_posts
        INNER JOIN wp_postmeta m1 ON wp_posts.ID = m1.post_id
        INNER JOIN wp_postmeta m2 ON wp_posts.ID = m2.post_id
        INNER JOIN wp_postmeta m3 ON wp_posts.ID = m3.post_id
        INNER JOIN wp_postmeta m4 ON m3.meta_value = m4.post_id
        INNER JOIN wp_postmeta m5 ON m3.meta_value = m5.post_id
        INNER JOIN wp_postmeta m6 ON '{invno}' = m6.post_id
        INNER JOIN wp_postmeta m7 ON '{invno}' = m7.post_id
        INNER JOIN wp_postmeta m8 ON '{invno}' = m8.post_id
        INNER JOIN wp_postmeta m9 ON '{invno}' = m9.post_id
        INNER JOIN wp_postmeta mt ON '{invno}' = mt.post_id
        INNER JOIN wp_usermeta um ON m8.meta_value = um.user_id
        INNER JOIN wp_usermeta um2 ON m8.meta_value = um2.user_id
        WHERE wp_posts.post_type = 'estate_property'
        AND wp_posts.post_status = 'publish'
        AND wp_posts.ID = '{property_id}'
        AND m1.meta_key = 'about_neighborhood'
        AND m2.meta_key = 'property_address'
        AND m3.meta_key = '_thumbnail_id'
        AND m4.meta_key = '_wp_attached_file'
        AND m5.meta_key = '_wp_attachment_metadata'
        AND m6.meta_key = 'month_price'
        AND m7.meta_key = 'depozit_paid'
        AND m8.meta_key = 'buyer_id'
        AND m9.meta_key = 'purchase_date'
        AND mt.meta_key = 'item_price'
        AND (um.meta_key = 'first_name' AND LENGTH(um.meta_value) > 0)
        AND (um2.meta_key = 'last_name' AND LENGTH(um2.meta_value) > 0)
      
        """

        #print(sqlqry)
        result = con.execute(text(sqlqry)).fetchall()
        count = len(result)

        row = result[0]  # Get the first (and only) row

        # Access values using indexing
        post_date = row[0]
        post_title = row[1]
        property_address = row[2]
        about_neighborhood = row[3]

        # Or access values using attribute-based access
        post_date = row.post_date
        post_title = row.post_title
        property_address = row.property_address
        about_neighborhood = row.about_neighborhood
        images_id = row.images_id
        image_path = row.image_path
        images_data = row.images_data
        monthly_fee = row.monthly_fee
        total_paid = row.total_paid
        first_name = row.first_name
        last_name = row.last_name
        inv_date = row.inv_date
        item_price_total = row.item_price_total

        full_name = f"{row.last_name}, {row.first_name}"

        # Print the values
        print("Post Date:", post_date)
        print("Post Title:", post_title)
        print("Property Address:", property_address)
        print("Monthly fee:", monthly_fee)
        print("Total Paid:", total_paid)
        print("Item Price Total:", item_price_total)

        datetime_obj = datetime.datetime.strptime(inv_date, "%Y-%m-%d %H:%M:%S")
        date_without_time = datetime_obj.replace(hour=0, minute=0, second=0, microsecond=0)
        formatted_date = date_without_time.strftime("%b %d, %Y")
        print(formatted_date)

        # Convert the strings to integers
        total_paid_float = float(total_paid)
        monthly_fee_float = float(monthly_fee)
        item_price_float = float(item_price_total)

        # Perform the subtraction

        #result = round(monthly_fee_float - total_paid_float , 2)
        result = round(item_price_float - monthly_fee_float , 2)
        print('Printing result......')
        print(result)

        # Convert the result back to a string if needed
        service_fee_str = str(result)
       

       
        # Load the email template and populate it with data
        #html_content = render_to_string('wpxapp/receipt_email_template.html', {
        #html_content = render_to_string('wpxapp/new_receipt_template.html', {
        html_content = render_to_string('wpxapp/referral_receipt_email_template.html', {
            'customer_name': full_name,
            'receipt_date': formatted_date,
            'receipt_number': receipt_number,
            'period': period,
            'host': host,
            'property_name': property_name,
            'booking_number': bookid,
            'first_month_rent': monthly_fee,
            'total_amount': item_price_total,
            'service_fee': service_fee_str,
        })

        # Create the email message
        subject = 'Thank you for booking with us!'
        from_email = 'Nomadroof <no-reply@nomadroof.com>'
        #to_email = ['darwin.robinson8@gmail.com']  # Use the recipient's email address
        #message = EmailMultiAlternatives(subject, '', from_email, to_email)
        to_email = [email]  # Use the recipient's email address
        bcc_email = ['darwin.robinson8@gmail.com', 'tomg_g@hotmail.com']  # Your email address
        message = EmailMultiAlternatives(subject, '', from_email, to_email, bcc_email) 
        message.attach_alternative(html_content, "text/html")

        try:
            # Send the email
            message.send()
        except Exception as e:
            # Return a JSON response with an error message
            data = {
                'error': f'Failed to send email to {email}: {str(e)}'
            }
            return JsonResponse(data, status=500)

    # Return a JSON response indicating success
    data = {
        'message': 'Emails sent successfully.'
    }
    return JsonResponse(data)


def sendemailinvoices(request):
    con = engine.connect()

    rows = json.loads(request.GET.get('rows'))
    # Create a list to hold records
    email_records = []
    grand_total = 0

    for booking in rows:
        tenant = booking["tenant"]
        email = booking["email"]
        checkin = booking["checkin"]
        checkout = booking["checkout"]
        period = booking["period"]
        host = booking["host"]
        property_name = booking["property"]
        bookid = booking["bookid"]
        invno = booking["invno"]
      


        # Split the string at the dash and take the first part
        bookid = bookid.split("-")[0]

        # Remove any leading or trailing whitespace
        bookid = bookid.strip()

        print(bookid)

        receipt_number = bookid + invno

        split_data = property_name.split('--')

        # Extract the number and text after the dashes
        property_id = split_data[0].strip()
        property_name = split_data[1].strip()

        print("Property ID:", property_id)
        print("Name:", property_name)
         
        
        print("Inv #:", invno)

        sqlqry = f"""
        SELECT wp_posts.post_date, wp_posts.post_title, m2.meta_value as property_address, 
        m1.meta_value as about_neighborhood, m3.meta_value images_id, m4.meta_value as image_path,
        m5.meta_value as images_data, m6.meta_value as monthly_fee, m7.meta_value as total_paid, um.meta_value as first_name, 
        um2.meta_value as last_name, m8.meta_value, wp_posts.post_author, m9.meta_value as inv_date, mt.meta_value as item_price_total
        FROM wp_posts
        INNER JOIN wp_postmeta m1 ON wp_posts.ID = m1.post_id
        INNER JOIN wp_postmeta m2 ON wp_posts.ID = m2.post_id
        INNER JOIN wp_postmeta m3 ON wp_posts.ID = m3.post_id
        INNER JOIN wp_postmeta m4 ON m3.meta_value = m4.post_id
        INNER JOIN wp_postmeta m5 ON m3.meta_value = m5.post_id
        INNER JOIN wp_postmeta m6 ON '{invno}' = m6.post_id
        INNER JOIN wp_postmeta m7 ON '{invno}' = m7.post_id
        INNER JOIN wp_postmeta m8 ON '{invno}' = m8.post_id
        INNER JOIN wp_postmeta m9 ON '{invno}' = m9.post_id
        INNER JOIN wp_postmeta mt ON '{invno}' = mt.post_id
        INNER JOIN wp_usermeta um ON m8.meta_value = um.user_id
        INNER JOIN wp_usermeta um2 ON m8.meta_value = um2.user_id
        WHERE wp_posts.post_type = 'estate_property'
        AND wp_posts.post_status = 'publish'
        AND wp_posts.ID = '{property_id}'
        AND m1.meta_key = 'about_neighborhood'
        AND m2.meta_key = 'property_address'
        AND m3.meta_key = '_thumbnail_id'
        AND m4.meta_key = '_wp_attached_file'
        AND m5.meta_key = '_wp_attachment_metadata'
        AND m6.meta_key = 'month_price'
        AND m7.meta_key = 'depozit_paid'
        AND m8.meta_key = 'buyer_id'
        AND m9.meta_key = 'purchase_date'
        AND mt.meta_key = 'item_price'
        AND (um.meta_key = 'first_name' AND LENGTH(um.meta_value) > 0)
        AND (um2.meta_key = 'last_name' AND LENGTH(um2.meta_value) > 0)
      
        """

        #print(sqlqry)
        result = con.execute(text(sqlqry)).fetchall()
        count = len(result)

        row = result[0]  # Get the first (and only) row

        # Access values using indexing
        post_date = row[0]
        post_title = row[1]
        property_address = row[2]
        about_neighborhood = row[3]

        # Or access values using attribute-based access
        post_date = row.post_date
        post_title = row.post_title
        property_address = row.property_address
        about_neighborhood = row.about_neighborhood
        images_id = row.images_id
        image_path = row.image_path
        images_data = row.images_data
        monthly_fee = row.monthly_fee
        total_paid = row.total_paid
        first_name = row.first_name
        last_name = row.last_name
        inv_date = row.inv_date
        item_price_total = row.item_price_total

        full_name = f"{row.last_name}, {row.first_name}"

        # Print the values
        print("Post Date:", post_date)
        print("Post Title:", post_title)
        print("Property Address:", property_address)
        print("Monthly fee:", monthly_fee)
        print("Total Paid:", total_paid)
        print("Item Price Total:", item_price_total)
        print("Period:", period)

        datetime_obj = datetime.datetime.strptime(inv_date, "%Y-%m-%d %H:%M:%S")
        date_without_time = datetime_obj.replace(hour=0, minute=0, second=0, microsecond=0)
        formatted_date = date_without_time.strftime("%b %d, %Y")
        print(formatted_date)

        # Convert the strings to integers
        total_paid_float = float(total_paid)
        monthly_fee_float = float(monthly_fee)
        item_price_float = float(item_price_total)

        # Perform the subtraction

        #result = round(monthly_fee_float - total_paid_float , 2)
        result = round(item_price_float - monthly_fee_float , 2)
        print('Populating array......')
        print(result)

        # Convert the result back to a string if needed
        service_fee_str = str(result)

        # Your existing code for retrieving data from 'booking'
        email_records.append({
            'tenant': full_name,
            'email': email,
            'checkin': checkin,
            'checkout': checkout,
            'receipt_date': formatted_date,
            'receipt_number': receipt_number,
            'period': period,
            'host': host,
            'property': property_name,
            'booking_number': bookid,
            'monthly_fee': monthly_fee,
            'total_amount': item_price_total,
            'service_fee': service_fee_str,
            'host': host,
            
        })

        grand_total +=  item_price_float
       

       
        # Load the email template and populate it with data
        #html_content = render_to_string('wpxapp/receipt_email_template.html', {
        #html_content = render_to_string('wpxapp/new_receipt_template.html', {
        """ html_content = render_to_string('wpxapp/invoices_email_template.html', {
            'customer_name': full_name,
            'receipt_date': formatted_date,
            'receipt_number': receipt_number,
            'period': period,
            'host': host,
            'property_name': property_name,
            'booking_number': bookid,
            'first_month_rent': monthly_fee,
            'total_amount': item_price_total,
            'service_fee': service_fee_str,
        }) """

       

    context = {
        'email_records': email_records,
        'grand_total': grand_total,
    } 
        
    html_content = render_to_string('wpxapp/invoices_email_template.html', context)

    # Create the email message
    subject = 'Invoices Nomadroof'
    from_email = 'Nomadroof <no-reply@nomadroof.com>'
    to_email = ['darwin.robinson8@gmail.com']  # Use the recipient's email address
    message = EmailMultiAlternatives(subject, '', from_email, to_email)
      
    message.attach_alternative(html_content, "text/html")

    try:
        # Send the email
        message.send()
    except Exception as e:
        # Return a JSON response with an error message
        data = {
            'error': f'Failed to send email to {email}: {str(e)}'
        }
        return JsonResponse(data, status=500)

    # Return a JSON response indicating success
    data = {
        'message': 'Emails sent successfully.'
    }
    return JsonResponse(data)


def sendemailpending23(request):
    # Retrieve data from the selected row
    """ email = request.GET.get('email', '')
    tenant = request.GET.get('tenant', '')
    checkin = request.GET.get('checkin', '')
    checkout = request.GET.get('checkout', '')
    period = request.GET.get('period', '')
    host = request.GET.get('host', '')
    property_name = request.GET.get('property', '')
    booking_number = '123456'
    invoice_number = '678888'
 """
    email = request.GET.get('email')
    tenant = request.GET.get('tenant')
    checkin = request.GET.get('checkin')
    checkout = request.GET.get('checkout')
    period = request.GET.get('period')
    host = request.GET.get('host')
    property_name = request.GET.get('property')
    rows = json.loads(request.GET.get('rows'))
    booking_number = '123456'
    invoice_number = '678888'

    for bookings in rows:
        tenant = bookings["tenant"]
        myemail = bookings["email"]
        checkin = bookings["checkin"]
        mycheckout = bookings["checkout"]
        property_name = bookings["property"]
        booking_number = bookings["bookid"]
        print(tenant)

    print(rows)

    # Load the email template and populate it with data
    html_content = render_to_string('wpxapp/pending_email_template.html', {
        'tenant': tenant,
        'checkin': checkin,
        'checkout': checkout,
        'period': period,
        'host': host,
        'property_name': property_name,
        'booking_number': booking_number,
        'invoice_number': invoice_number,
    })

    # Create the email message
    subject = 'Reservation Confirmation Reminder'
    from_email = 'hello@nomadroof.com'
    to_email = ['darwin.robinson8@gmail.com', 'tomg_g@hotmail.com' ]  # Use the recipient's email address
    message = EmailMultiAlternatives(subject, '', from_email, to_email)
    message.attach_alternative(html_content, "text/html")

    try:
        # Send the email
        message.send()

        # Return a JSON response indicating success
        data = {
            'message': 'Email sent successfully.'
        }
        return JsonResponse(data)
    except Exception as e:
        # Return a JSON response with an error message
        data = {
            'error': 'Failed to send email: ' + str(e)
        }
        return JsonResponse(data, status=500)
